const { fetchText, getMessageConsent } = require('./index')
const didJWT = require('did-jwt')
const ethers = require('ethers')
require('https-did-resolver').default()
require('muport-did-resolver')()

module.exports = {
  /**
   * Verifies that the gist contains the given muportDID and returns the users github username.
   * Throws an error otherwise.
   *
   * @param     {String}            did                     The muport DID of the user
   * @param     {Object}            gistUrl                 URL of the proof
   * @return    {Object}                                    Object containing username, and proof
   */
  verifyGithub: async (did, gistUrl) => {
    if (!gistUrl || gistUrl.trim() === '') {
      return null
    }

    let gistFileContent = await fetchText(gistUrl)

    if (gistFileContent.indexOf(did) === -1) {
      throw new Error('Gist File provided does not contain the correct DID of the user')
    }

    const username = gistUrl.split('/')[3]
    return {
      username,
      proof: gistUrl
    }
  },

  /**
   * Verifies that the tweet contains the given muportDID and returns the users twitter username.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyTwitter: async (did, claim) => {
    if (!claim) return null
    const verified = await didJWT.verifyJWT(claim)
    if (verified.payload.sub !== did) {
      throw new Error('Verification not valid for given user')
    }
    const claimData = verified.payload.claim
    if (!claimData.twitter_handle || !claimData.twitter_proof) {
      throw new Error('The claim for your twitter is not correct')
    }
    return {
      username: claimData.twitter_handle,
      proof: claimData.twitter_proof,
      verifiedBy: verified.payload.iss
    }
  },

  /**
   * Verifies that the code entered by the user is the same one that was sent via email.
   * Throws an error otherwise.
   *
   * @param     {String}            did             The muport DID of the user
   * @param     {String}            claim           A did-JWT with claim
   * @return    {Object}                            Object containing username, proof, and the verifier
   */
  verifyEmail: async (did, claim) => {
    if (!claim) return null
    const verified = await didJWT.verifyJWT(claim)
    if (verified.payload.sub !== did) {
      throw new Error('Verification not valid for given user')
    }
    const claimData = verified.payload.claim
    if (!claimData.email_address) {
      throw new Error('The claim for your email address is not correct')
    }
    return {
      email_address: claimData.email_address,
      verifiedBy: verified.payload.iss
    }
  },

  /**
   * Verifies that the proof for a did is correct
   *
   * @param     {String}            claim           A did-JWT with claim
   * @return    {String}                            The DID of the user
   */
  verifyDID: async (claim) => {
    const verified = await didJWT.verifyJWT(claim)
    return verified.payload.iss
  },

  /**
   * Verifies that the proof for an ethereum address is correct
   *
   * @param     {Object}    ethProof                      The claim generated by getLinkConsent
   * @param     {string}    ethProof.consent_msg
   * @param     {string}    ethProof.consent_signature
   * @param     {string}    ethProof.linked_did
   * @param     {String}    did                           The box' did
   * @return    {String}                                  The ethereum address used to sign the message
   */
  verifyEthereum: async (ethProof, did) => {
    const consentMsg = ethProof.version ?  ethProof.message : ethProof['consent_msg']
    const consentSig = ethProof.version ?  ethProof.signature : ethProof['consent_signature']

    // Make sure the message matches our expectation
    const expected = getMessageConsent(did)
    if (consentMsg !== expected) {
      throw new Error(`Invalid consent message, got: "${consentMsg}", expected: "${expected}"`)
    }

    // Validate the signature
    return ethers.utils.verifyMessage(consentMsg, consentSig)
  }
}
